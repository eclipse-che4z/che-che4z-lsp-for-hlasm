The purpose of the `dispatcher` is to execute an infinite loop in which it read JSON messages from `json_source` and passes them to the [`request_manager`](https://github.com/eclipse/che-che4z-lsp-for-hlasm/wiki/Request-manager). At the same time, it is able to write responses in the correct format.

The language server communicates with the LSP client either via standard input and output or a TCP/IP connection, in the case of running under Node.js only standard I/O channels are supported.
In the case of TCP/IP, the VS Code extension identified a free TCP port and passes it to the language server as an argument. Thanks to the ASIO library (see [[third party libraries]]) implementation of the `std::iostream` interface, the implementation is able to completely abstract from the fact that it is communicating through TCP and not through the standard IO.

The DAP communication is tunneled via notification messages through the existing LSP channel. Incoming messages are routed to the correct components via `message_router` class. In case of DAP messages the incoming message envelop is stripped away by `dap::unmessage_wrapper`, similarly outgoing messages are wrapped by `dap::message_wrapper`. Both of these classes implement `json_source` or `json_sink` respectively to shield the server implementation from this implementation detail.
Once the macro tracer is started, a registration message is processed by the server and a new `dap_session` is started by the `dap_session_manager` to handle the debugging session.

Both the LSP server and (possibly multiple) DAP servers run in their own thread. All of them use simple `blocking_queue` for passing parsed JSON objects from the main thread.