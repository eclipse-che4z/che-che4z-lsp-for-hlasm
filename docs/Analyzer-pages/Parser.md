Parser component takes tokens produced by lexer from token stream and recognizes HLASM statements. The parser inherits from the HLASM recognizer generated by ANTLR (see Antlr in [[Third party libraries]]) to provide further operations.

### Parser workflow

Parser (in code referenced as `parser_impl`) implements opencode statement provider interface. This means that, according to the statement passing in [[Statement providers]], parser needs to parse each statement in *two steps*:

1.  Parser calls rule `label_instr`. It parses label and instruction fields into respective structures. The operand and remark field is stored as a string.

2.  After retrieving the processing format, the parser selects corresponding rule to parse operands. With the rule, it parses remaining string from the previous step.

For the means of parsing remaining strings, parser subcomponent contains actually *two parsers*. The first one parses statement after statement from a source file. The second parses the operands from the string passed by the first parser.

To achieve operands having correctly set ranges prior to the source file rather than to the passed string, the parser uses *Range provider*. It helps the second parser to have ranges of reparsed operands consistent with the ranges of other fields. It is initialized with the begin location of operand field in the statement and all ranges furtherly created in parsing are adjusted to have correct boundaries.

### Statement structure

During parsing of a statement, several structures are created and collected. They are `label_si, instruction_si, operand_si, remark_si` (*si* as semantic information). They are collected with `collector` and built into `statement_si` structure.

Label and instruction structures can contain either identifier of a symbol or — when in model statement — concatenation of strings and variable symbols. Remark field is simply just a string as it serves as a commentary statement field. Operand field contains list of operands used in the statement. They can be of several formats.

#### Operand formats

The statement processor can request parser to retrieve statements with this operand formats:

-   *machine/assembler/conditional assembly/macro* – instruction operands. Each type of instruction has its specific format.

-   *model* – operands for model statements. It is a chain of strings and variable symbols.

-   *deferred* – operands with not yet known format. Stored as a string.

Each operand format has corresponding *operand structure*. They all inherit abstract `operand` and each have various children for different kinds of the operand format (see the picture below). Assembler and Machine operand structures inherit from *Evaluable operand*. It is a common structure for operand objects that are composed of resolvable objects (see *Symbol dependency tables* in [[HLASM context tables]).

<img src="img/operand_arch.svg" alt="Operand structure inheritance." />

#### Concatenation structures

A model statement is a statement that contains a variable symbol in any of the statement fields. This variable symbol is further to be substituted by an arbitrary string and then re-parsed. Hence, the field is formed by concatenating individual sub-fields, which are represented by specialized structures. The concatenation can be further evaluated to produce the final string.

The helper structures are:

-   `char_str` – a character string.

-   `var_sym` – a substitutable variable symbol.

-   `dot`, `equals` – characters with special meaning.

-   `sublist` – a recursive concatenation enclosed in parentheses.

### Grammar implementation

Grammar rules describing parser are separated into several files (see the [[Grammar visualization]]):

-   `hlasm_parser.g4` – Top level rules are stored here.

-   `lookahead_rules.g4` – Rules for lookahead mode.

-   `label_field_rules.g4` – Rules taking care of label field of statement.

-   `instruction_field_rules.g4` – Rules taking care of instruction field of statement.

-   `operand_field_rules.g4` – Rules taking care of operand field of statement.

-   `macro/machine/assembler/ca/model/deferred_operand_rules.g4` – Various operand field rules.

-   `ca/asm_expression_rules.g4` – Rules for expressions.

-   `data_def_rules.g4` – Rules for data definition.
